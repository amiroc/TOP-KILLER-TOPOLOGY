import numpy as np
import matplotlib.pyplot as plt
import math
from mpl_toolkits.mplot3d import Axes3D  # noqa: F401 (necesario para la proyección 3D)
import matplotlib.cm as cm

def dibujar_poligono(n_lados):
    angulos = np.linspace(0, 2*np.pi, n_lados, endpoint=False)
    x = np.cos(angulos)
    y = np.sin(angulos)

    fig, ax = plt.subplots(figsize=(8, 8))
    ax.plot(np.append(x, x[0]), np.append(y, y[0]), 'b-')
    ax.set_aspect('equal')
    ax.set_title(f'Polígono regular de {n_lados} lados', fontsize=16)
    ax.grid(True)

    for i, (xi, yi) in enumerate(zip(x, y)):
        ax.annotate(str(i+1), (xi, yi), xytext=(5, 5), textcoords='offset points', fontsize=12)

    plt.show()

def analizar_topologia(n_lados):
    print(f"\nAnálisis topológico para un polígono de {n_lados} lados:")
    genero_maximo = n_lados // 4
    lados_requeridos = genero_maximo * 4

    if n_lados % 4 == 0:
        genero = n_lados // 4
        print(f"✓ Este polígono puede representar un {genero}-toro (toro con {genero} agujeros)")
        print(f"✓ Relación: Número de lados = 4 × género → {n_lados} = 4 × {genero}")
        print("\nIdentificaciones de bordes para formar el toro:")
        for i in range(genero):
            print(f"  Par {i+1}: a{i+1} ↔ a{i+1}⁻¹, b{i+1} ↔ b{i+1}⁻¹")
        return genero, genero_maximo
    else:
        print("✗ Este polígono no puede representar un n-toro con la representación estándar")
        print(f"  Sin embargo, teóricamente podría representar hasta {genero_maximo} agujeros (género {genero_maximo})")
        print(f"  Para representar un {genero_maximo}-toro, se necesitarían {lados_requeridos} lados")
        print(f"  Le sobran {n_lados - lados_requeridos} lados para una representación estándar")
        return None, genero_maximo

def visualizar_identificaciones(n_lados):
    if n_lados % 4 != 0:
        print("No se pueden visualizar identificaciones para un n-toro con este número de lados")
        return

    angulos = np.linspace(0, 2*np.pi, n_lados, endpoint=False)
    x = np.cos(angulos)
    y = np.sin(angulos)

    fig, ax = plt.subplots(figsize=(10, 10))
    ax.plot(np.append(x, x[0]), np.append(y, y[0]), 'b-')
    ax.set_aspect('equal')
    ax.set_title(f'Identificaciones de bordes para un {n_lados//4}-toro', fontsize=16)
    ax.grid(True)

    for i, (xi, yi) in enumerate(zip(x, y)):
        ax.annotate(str(i+1), (xi, yi), xytext=(5, 5), textcoords='offset points', fontsize=12)

    colores = ['red', 'green', 'blue', 'orange', 'purple', 'brown']

    genero = n_lados // 4
    for i in range(genero):
        color = colores[i % len(colores)]
        lado_a1 = i * 4
        lado_a2 = i * 4 + 2

        dx_a1 = x[(lado_a1+1) % n_lados] - x[lado_a1]
        dy_a1 = y[(lado_a1+1) % n_lados] - y[lado_a1]
        ax.arrow(x[lado_a1] + dx_a1/3, y[lado_a1] + dy_a1/3,
                 dx_a1/3, dy_a1/3, head_width=0.05, head_length=0.05,
                 fc=color, ec=color, length_includes_head=True)

        dx_a2 = x[(lado_a2+1) % n_lados] - x[lado_a2]
        dy_a2 = y[(lado_a2+1) % n_lados] - y[lado_a2]
        ax.arrow(x[lado_a2] + dx_a2/3, y[lado_a2] + dy_a2/3,
                 dx_a2/3, dy_a2/3, head_width=0.05, head_length=0.05,
                 fc=color, ec=color, length_includes_head=True)

        mid_x_a1 = (x[lado_a1] + x[(lado_a1+1) % n_lados]) / 2
        mid_y_a1 = (y[lado_a1] + y[(lado_a1+1) % n_lados]) / 2
        ax.text(mid_x_a1 * 1.2, mid_y_a1 * 1.2, f'a{i+1}', fontsize=12, color=color,
                ha='center', va='center')

        mid_x_a2 = (x[lado_a2] + x[(lado_a2+1) % n_lados]) / 2
        mid_y_a2 = (y[lado_a2] + y[(lado_a2+1) % n_lados]) / 2
        ax.text(mid_x_a2 * 1.2, mid_y_a2 * 1.2, f'a{i+1}⁻¹', fontsize=12, color=color,
                ha='center', va='center')

        lado_b1 = i * 4 + 1
        lado_b2 = i * 4 + 3

        dx_b1 = x[(lado_b1+1) % n_lados] - x[lado_b1]
        dy_b1 = y[(lado_b1+1) % n_lados] - y[lado_b1]
        ax.arrow(x[lado_b1] + dx_b1/3, y[lado_b1] + dy_b1/3,
                 dx_b1/3, dy_b1/3, head_width=0.05, head_length=0.05,
                 fc=color, ec=color, length_includes_head=True)

        dx_b2 = x[(lado_b2+1) % n_lados] - x[lado_b2]
        dy_b2 = y[(lado_b2+1) % n_lados] - y[lado_b2]
        ax.arrow(x[lado_b2] + dx_b2/3, y[lado_b2] + dy_b2/3,
                 dx_b2/3, dy_b2/3, head_width=0.05, head_length=0.05,
                 fc=color, ec=color, length_includes_head=True)

        mid_x_b1 = (x[lado_b1] + x[(lado_b1+1) % n_lados]) / 2
        mid_y_b1 = (y[lado_b1] + y[(lado_b1+1) % n_lados]) / 2
        ax.text(mid_x_b1 * 1.2, mid_y_b1 * 1.2, f'b{i+1}', fontsize=12, color=color,
                ha='center', va='center')

        mid_x_b2 = (x[lado_b2] + x[(lado_b2+1) % n_lados]) / 2
        mid_y_b2 = (y[lado_b2] + y[(lado_b2+1) % n_lados]) / 2
        ax.text(mid_x_b2 * 1.2, mid_y_b2 * 1.2, f'b{i+1}⁻¹', fontsize=12, color=color,
                ha='center', va='center')

    plt.show()

def visualizar_3d_toro_aproximado(genero):
    """
    Aproximación visual en 3D de un g-toro: se colocan 'genero' toros
    (cada uno con un agujero) dispuestos en un anillo para sugerir múltiple agujeros.
    NOTA: esto es una visualización aproximada, no una representación topológica
    fiel del g-toro en R^3.
    """
    if genero == 0:
        print("Género 0 corresponde a una esfera, no a un toro")
        return

    fig = plt.figure(figsize=(10, 8))
    ax = fig.add_subplot(111, projection='3d')

    # parámetros base del "tubo" y del radio de cada toro
    tubo_r = max(0.3, 0.8 - 0.02 * genero)   # radio del tubo (se reduce si hay muchos)
    toro_R = max(0.9, 1.5 - 0.01 * genero)   # radio mayor local de cada toro (ajustable)

    # radio del círculo sobre el que se colocan los centros (evita solapamiento)
    radius_circle = max(3.0, 1.2 * genero)

    # malla de parametrización
    u = np.linspace(0, 2 * np.pi, 40)
    v = np.linspace(0, 2 * np.pi, 30)
    u, v = np.meshgrid(u, v)

    # colormap según número de tori
    cmap = cm.get_cmap('hsv', genero)

    for i in range(genero):
        ang = 2 * np.pi * i / genero
        cx = radius_circle * np.cos(ang)
        cy = radius_circle * np.sin(ang)
        cz = 0.0

        # coordenadas del toro i
        x = cx + (toro_R + tubo_r * np.cos(v)) * np.cos(u)
        y = cy + (toro_R + tubo_r * np.cos(v)) * np.sin(u)
        z = cz + tubo_r * np.sin(v)

        color = cmap(i)
        ax.plot_surface(x, y, z, rstride=1, cstride=1, facecolors=None, shade=True, alpha=0.8)

    # ajuste de ejes
    limit = radius_circle + toro_R + tubo_r + 1
    ax.set_xlim([-limit, limit])
    ax.set_ylim([-limit, limit])
    ax.set_zlim([-tubo_r - 1, tubo_r + 1])
    ax.set_xlabel('X')
    ax.set_ylabel('Y')
    ax.set_zlabel('Z')
    ax.set_title(f'Aproximación 3D de un {genero}-toro (visualización aproximada)', fontsize=14)
    plt.tight_layout()
    plt.show()

def visualizar_3d_poligono(n_lados):
    angulos = np.linspace(0, 2*np.pi, n_lados, endpoint=False)
    x = np.cos(angulos)
    y = np.sin(angulos)
    z = np.zeros_like(x)

    fig = plt.figure(figsize=(10, 8))
    ax = fig.add_subplot(111, projection='3d')

    vertices = list(zip(x, y, z))
    vertices.append(vertices[0])
    vertices = np.array(vertices)
    ax.plot(vertices[:, 0], vertices[:, 1], vertices[:, 2], 'b-', linewidth=2)
    ax.scatter(x, y, z, c='r', marker='o', s=50)

    for i, (xi, yi, zi) in enumerate(zip(x, y, z)):
        ax.text(xi, yi, zi, f'{i+1}', fontsize=12)

    ax.set_xlim([-1.5, 1.5])
    ax.set_ylim([-1.5, 1.5])
    ax.set_zlim([-0.1, 0.1])
    ax.set_xlabel('X')
    ax.set_ylabel('Y')
    ax.set_zlabel('Z')
    ax.set_title(f'Polígono regular de {n_lados} lados en 3D', fontsize=16)

    plt.show()

def calcular_maximos_agujeros(n_lados):
    print(f"\nCálculo de la cantidad máxima de agujeros para {n_lados} lados:")
    genero_maximo = n_lados // 4
    lados_requeridos = genero_maximo * 4

    print(f"• Con {n_lados} lados, teóricamente se pueden representar hasta {genero_maximo} agujeros")
    print(f"• Esto requeriría {lados_requeridos} lados para una representación estándar")

    if n_lados % 4 == 0:
        print(f"• El polígono tiene exactamente los lados necesarios para representar un {genero_maximo}-toro")
    else:
        print(f"• El polígono tiene {n_lados - lados_requeridos} lados de más para una representación estándar")

    print(f"\nEjemplos de polígonos que pueden representar n-toros:")
    for g in range(1, min(10, genero_maximo + 2)):
        lados_necesarios = 4 * g
        if lados_necesarios <= n_lados:
            print(f"• {g}-toro: {lados_necesarios} lados")
        else:
            print(f"• {g}-toro: {lados_necesarios} lados (más de los disponibles)")
    return genero_maximo

# Programa principal
if __name__ == "__main__":
    try:
        n = int(input("Ingrese el número de lados del polígono (ej: 24 para un 6-toro): "))
        if n < 3:
            print("El número de lados debe ser al menos 3")
        else:
            dibujar_poligono(n)
            genero, genero_maximo = analizar_topologia(n)
            calcular_maximos_agujeros(n)

            if n % 4 == 0:
                visualizar_identificaciones(n)

            visualizar_3d_poligono(n)

            if genero is not None and genero > 0:
                # Aquí usamos la aproximación en 3D para visualizar "genero" agujeros
                visualizar_3d_toro_aproximado(genero)
            else:
                print("\nNo se visualiza el toro 3D ya que el polígono no representa un n-toro estándar")

    except ValueError:
        print("Por favor ingrese un número entero válido")
